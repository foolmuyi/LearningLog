- [认识HALCON](#认识halcon)
  - [HALCON基础架构](#halcon基础架构)
  - [HDevelop界面](#hdevelop界面)
    - [算子窗口](#算子窗口)
  - [图像采集](#图像采集)
    - [获取非实时图像](#获取非实时图像)
      - [`read_image()`语句](#read_image语句)
      - [`Ctrl+R`快捷键](#ctrlr快捷键)
      - [Image Acquisition](#image-acquisition)
    - [获取实时图像](#获取实时图像)
  - [数据类型](#数据类型)
    - [通道（channel）](#通道channel)
    - [区域（Region）](#区域region)
    - [XLD](#xld)
- [基础语法](#基础语法)
  - [变量](#变量)
    - [变量赋值](#变量赋值)
    - [tuple操作](#tuple操作)
  - [流程控制](#流程控制)
    - [if-else语句](#if-else语句)
    - [while语句](#while语句)
    - [repeat语句](#repeat语句)
    - [for语句](#for语句)
    - [switch语句](#switch语句)
    - [continue语句和break语句](#continue语句和break语句)
  - [操作符](#操作符)
- [图像处理](#图像处理)
  - [创建ROI](#创建roi)
    - [图像窗口ROI工具](#图像窗口roi工具)
    - [代码设定ROI](#代码设定roi)
    - [交互式绘制ROI](#交互式绘制roi)
  - [图像变换](#图像变换)
    - [仿射变换](#仿射变换)
    - [投影变换](#投影变换)
  - [图像增强](#图像增强)
    - [灰度变换](#灰度变换)
    - [直方图均衡化](#直方图均衡化)
    - [图像平滑](#图像平滑)
    - [图像锐化](#图像锐化)
    - [频域滤波](#频域滤波)
  - [图像分割](#图像分割)
    - [阈值分割](#阈值分割)
    - [边缘检测](#边缘检测)



# 认识HALCON

## HALCON基础架构

![基础架构](./imgs/basic_arch.png)

HDevelop可以做什么：
- 直接连接采集卡或者相机；
- 查看图像的各种数据；
- 视觉方案可行性研究；
- 开发一个视觉检测项目；
- 测试不同算子的处理效果；
- 将HALCON程序导出为Python、C、C++、C#或者VB程序；
- 更多...

HDevelop不能做什么：
- 不能直接生成一个完整的带用户界面和其他辅助功能，可以直接运行在实际项目工控机上的应用程序。

一个完整的视觉程序开发过程通常如下图所示：
![完整视觉程序](./imgs/full_process.png)

## HDevelop界面

![界面](./imgs/ui.jpg)

### 算子窗口

![算子窗口](./imgs/operator_ui.png)

从算子窗口中我们可以看到，HALCON算子的参数分为图像变量（iconic）和控制变量（control）两类，各自分别又可以分为输入变量和输出变量，一般顺序为`operator(input iconic : output iconic : input control : output control)`，当然并不是每个算子都需要完整的四组参数。另外需要注意的是，算子对输入图像的操作并不是直接在原图上进行的，输入图像并不会被改变，处理结果会保存在图像输出变量。

## 图像采集

### 获取非实时图像

获取非实时图像即读取现成的图片，有以下三种方式。

#### `read_image()`语句

常规方式，不再赘述。举例：`read_image(Image, './images/lena.jpeg')`。

#### `Ctrl+R`快捷键

使用`Ctrl+R`快捷键，会弹出读取图像窗口，我们可以浏览文件夹选择要读取的图片，然后点击确定即可，软件会自动在程序光标处插入一行`read_image()`语句。

#### Image Acquisition

使用Image Acquisition不仅可以读取单张图片，还可以批量读取指定文件夹内的图片。使用时只需点击工具栏相机样式的图标或者菜单栏“助手” → “打开新的Image Acquisition”，然后在弹出窗口中选择“图像文件” → “选择路径”选定图片文件夹路径，然后选择“代码生成” → “插入代码”，软件会自动在程序中光标处插入如下一段代码：

```
* Image Acquisition 07: Code generated by Image Acquisition 07
list_files ('C:/Users/muyi/AppData/Roaming/MVTec/HALCON-23.11-Progress/examples/images/bead', ['files','follow_links'], ImageFiles)
tuple_regexp_select (ImageFiles, ['\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima|hobj)$','ignore_case'], ImageFiles)
for Index := 0 to |ImageFiles| - 1 by 1
    read_image (Image, ImageFiles[Index])
    * Image Acquisition 07: Do something
endfor
```

从代码中我们可以看到，使用Image Acquisition读取图片文件夹时软件会自动生成一个for循环来逐一读取每一张图片，我们可以在此基础上根据需要修改自动生成的代码。

### 获取实时图像

获取实时图像即从相机获取图像，一般有两种方式：通过Image Acquisition获取和通过相机SDK获取。后者取决于具体的相机，在此我们仅介绍前者。

首先点击工具栏相机样式的图标或者菜单栏“助手” → “打开新的Image Acquisition”，选择“图像获取接口”，点击“自动检测接口”。检测到相机后，在“连接”选项卡点击“连接”，最后在“代码生成”选项卡点击“插入代码”即可。

注意事项：
- 在“参数”选项卡可以调整相机的各项参数，然后在“连接”选项卡点击“采集”（获取单帧图像）或者“实时”（获取视频流）即可看到调整参数后的效果。
- 在“代码生成”选项卡中有一个“采集模式”选项，可以选择“同步采集”或“异步采集”，其区别是：
   - 同步采集：程序发出指令，相机采集图像，程序获取图像，串行执行，可以保证获取的是相机最新一帧图像。
   - 异步采集：相机采集图像和程序获取图像并行执行，程序直接从相机存储中获取图像，获取的不一定是最新一帧图像。

## 数据类型

HALCON主要有以下数据类型：
- Iconic（图像变量）：Image（图像）、Region（区域）、E***x***tended ***L***ine ***D***escription（XLD）
- Control（控制变量）：String、Integer、Real、Handle...
- Tuple（类似于数组）

### 通道（channel）

一张图片可能是由多个通道的数据合成而来的，例如灰度图只有一个通道，彩色图有RGB三个通道，遥感图片可能有多个通道等。常用的通道相关的算子有：
- `count_channels`：获取图像的通道数
- `access_channel`：获取指定通道的图像
- `decompose3`：分解三通道图像
- `compose2`：合并两个通道
- `append_channel`：在图像上再附加一个通道

### 区域（Region）

Region指图像上的一块区域，一般对图像进行分割时会获得多个区域，例如使用`threshold`算子对灰度图进行阈值分割。

### XLD

XLD也叫亚像素精度轮廓，类似超分辨率的效果，可以得到比原始图像像素更精细的边缘。

# 基础语法

## 变量

### 变量赋值

HALCON不允许声明变量类型，直接对变量赋值，赋值符号为`:=`。例如：

```
a := 1
```

变量类型可以被改变。对tuple中指定索引赋值时，未指定的索引会自动填充0。并且tuple中可以包含多种数据类型。例如：

```
a := 1    \\ a = 1
a[1] := 2    \\ a = [1, 2]
a[4] := 3    \\ a = [1, 2, 0, 0, 3]
a[5] := 'HALCON'    \\ a = [1, 2, 0, 0, 3, 'HALCON']
```

### tuple操作

- 获取tuple长度：`len := |TupleName|`或`tuple_length(TupleName, len)`
- tuple添加元素：`TupleName := [TupleName, elementToAppend]`，例如：
  ```
  Tuple_1 := [1, 2, 3]
  Tuple_1 := [Tuple_1, 4]    \\ Tuple_1 = [1, 2, 3, 4]
  ```

## 流程控制

### if-else语句

```
if(condition)
    * Do someting...
elseif(condition)
    * Do something...
else
    * Do something...
endif
```

### while语句

```
while(condition)
    * Do something...
endwhile
```

### repeat语句

类似于do-while语句，不同的是当条件满足时程序退出循环而非继续循环。

```
repeat
    * Do something...
until(condition)
```

### for语句

```
for <index> := <start> to <end> by <step>
    * Do something...
endfor
```

### switch语句

```
switch (<var>)
    case 1:
        * Do something...
        break
    case 2:
    case 3:
        * Do something...
        break
    default:
        * Do something...
endswitch
```

### continue语句和break语句

HALCON也支持continue和break语句，且用法和C++等语言相同，不再赘述。

## 操作符

- `:=`：赋值
- `=`或`==`：相等
- `#`或`!=`：不等于
- `>`、`<`、`>=`、`<=`：大于、小于、大于等于、小于等于
- `and`、`or`、`not`、`xor`：与、或、非、异或
- `+`、`-`、`*`、`/`、`%`：加、减、乘、除、取余

# 图像处理

## 创建ROI

下面介绍三种在HALCON中创建ROI的方式。

### 图像窗口ROI工具

![ROI工具](./imgs/ROI.png)

如上图所示，点击图形窗口中的ROI工具，在弹出的窗口中选择一种形状（矩形、圆、椭圆等等），然后通过鼠标左键绘制右键确认，即可得到一个ROI区域，最后点击插入代码即可。而且还可以绘制多个ROI区域并进行求合集、交集等集合操作。

### 代码设定ROI

当然，如果已知ROI在图像中的位置形状，我们也可以直接在代码中指定ROI范围。例如，创建一个圆心在(250,200)半径为100的区域作为ROI：

```
gen_circle (ROI_0, 250, 200, 100)
```

### 交互式绘制ROI

有时我们需要在程序运行过程中让用户来绘制ROI，这就需要我们在恰当的位置弹出交互式的窗口，下面的例子即可实现这一功能，源文件见`./scripts/interactiveROI.hdev`。

```
read_image(Image, 'claudia')    * 读取图片
dev_open_window_fit_image(Image, 0, 100, -1, -1, ROIWindow)    * 打开一个新窗口
dev_display(Image)    * 在新窗口显示图片
disp_message(ROIWindow,'Please draw a circle.', 'image', 0, 0, 'red', 'true')    * 显示提示信息
draw_circle(ROIWindow, CenterY, CenterX, CenterR)    * 用户在图像上绘制ROI
gen_circle (ROI_0, CenterY, CenterX, CenterR)    * 生成ROI
reduce_domain (Image, ROI_0,ImageReduced)    * 从原图中抠出ROI部分
dev_clear_window()    * 清除显示的图片
dev_display(ImageReduced)    * 显示抠图结果
```

在上面的程序中，我们使用了`draw_circle`来获取用户绘制的ROI，这也限定了用户只能绘制圆形的ROI。实际上HALCON还提供了多种类似的算子，例如`draw_rectangle1`、`draw_ellipse`，`draw_polygon`等。其中`draw_polygon`比较特殊，因为用户在绘制多边形时其实绘制的是一条折线，我们需要先将首尾连接起来形成一个闭合图形，再进行抠图，也就是不能用`gen_polygon`（实际上也没有这个算子）来生成多边形而需要用`shape_trans`，如下所示：

```
draw_polygon (ROI_polygon, ROIWindow)
shape_trans(ROI_polygon, ROI_0, 'convex')
reduce_domain (Image, ROI_0,ImageReduced)
```

注意结合上面的代码和下面的图片观察每个图像变量的区别：

![多边形ROI](./imgs/polygon_ROI.png)

## 图像变换

关于图像变换的理论知识可以参考[机器视觉自动检测技术](../机器视觉自动检测技术/MachineVision.md)中的“图像变换”章节，本节只介绍HALCON中进行图像变换操作需要用到的算子。

### 仿射变换

- `hom_mat2d_translate`：2维平移变换
- `hom_mat2d_rotate`：2维旋转变换
- `hom_mat2d_scale`：2维缩放变换
- `hom_mat2d_identity`：生成一个2维齐次变换单位矩阵，即3×3单位阵
- `affine_trans_image`：对图像进行2维仿射变换

### 投影变换

- `hom_vector_to_proj_hom_mat2d`：根据四对输入的匹配点计算单应性变换矩阵
- `projective_trans_image`：对图片进行投影变换

## 图像增强

图像增强分类：

- 空间域
  - 点运算
    - 灰度变换
    - 直方图均衡化
  - 邻域运算
    - 图像平滑
    - 图像锐化
- 频率域
  - 低通滤波
  - 同态滤波
  - 高通滤波

### 灰度变换

灰度变换即对图像上每一个点的灰度值进行操作从而得到新的图像，大致又可分为线性变换、分段线性变换和非线性变换（对数变换、伽马变换等）。

- `invert_image`：灰度图像反转变换，`g' = 255 - g`
- `emphasize`：增大图像对比度
- `scale_image`：标准线性变换，可以设置斜率和截距

### 直方图均衡化

- `equ_histo_image`：直方图均衡化

### 图像平滑

- `gauss_distribution`：生成高斯噪声
- `add_noise_distribution`：向图像添加噪声
- `sp_distribution`：生成椒盐噪声
- `mean_image`：均值滤波
- `median_image`：中值滤波

### 图像锐化

- `roberts`：使用Roberts算子进行边缘检测
- `prewitt_amp`：使用Prewitt算子进行边缘检测（仅幅值）
- `prewitt_dir`：使用Prewitt算子进行边缘检测（幅值和方向）
- `sobel_amp`：使用Sobel算子进行边缘检测（仅幅值）
- `sobel_dir`：使用Sobel算子进行边缘检测（幅值和方向）
- `skeleton`：提取骨架
- `laplace`：使用Laplace算子进行边缘检测
- `laplace_of_gauss`：LoG算子，即先对图像进行高斯平滑去除一些噪声，再用Laplace算子检测边缘

### 频域滤波

- `fft_image`：计算图像的傅里叶变换
- `fft_image_inv`：计算图像的反向傅里叶变换
- `fft_generic`：计算图像的傅里叶变换或者反向傅里叶变换（通过输入参数选择），并且相比于`fft_image`和`fft_image_inv`可以设置更多参数，适用于较复杂的场景
- `gen_lowpass`：生成低通滤波器
- `gen_highpass`：生成高通滤波器
- `convol_fft`：使用滤波器对图像在频域做卷积

## 图像分割

### 阈值分割

- `gray_histo`：计算灰度的直方图分布
- `histo_to_thresh`：根据直方图进行阈值分割，返回每个分割区间的上下阈值
- `threshold`：根据给定灰度阈值对图像进行分割
- `auto_threshold`：综合上述三个算子的功能，一步输出根据灰度直方图进行阈值分割的结果
- `mean_image`：均值滤波
- `dyn_threshold`：根据原图像和处理后的图像（比如均值滤波后的图像）每个像素灰度的偏差值来确定局部阈值，从而对图像进行分割
- `select_shape`：根据面积、长、宽等多种特征来从众多区域中选择符合条件的区域

### 边缘检测